# Exercises

Start by opening the application in the browser and opening the browser Dev Tools.

TIP: It might be easier to read this rendered, for example by looking at in the browser: https://github.com/holyjak/fulcro-intro-wshop/blob/main/docs/Exercises.adoc

Note: You have about 5 - 10 minutes per exercise.

## Introductory exercises

### 1. Component tree

1. Open the React dev tools' **Components tab**
2. Explore the tree of the components displayed
3. Select one of the `TodoItem` elements - can you see its props on the right side (or at the bottom, on a smaller screen)? (Answer: yes and no :-))

We see that the components are nested in each other, creating a tree (with a single "branch" in this case):

.UI components tree
image::images/ui-tree.svg["UI tree",200,200]

The following code is a simplified version of the code defining the UI:

.UI code (simplified):
```clojure
(defsc TodoItem [_ props]
  {...}
  (dom/li (:item/label props)))

(defsc TodoList [_ props]
  {...}
  (dom/ul 
    (map #((com/factory TodoItem) %) 
         (:list/items props))))

(defsc Root [_ props]
  {...}
  (dom/div ((comp/factory TodoList) (:root/todo props))))
```

LESSON: The UI is indeed a tree of components: `Root > TodoList > TodoItem`.

### 2. Component props and query

React dev tools cannot show us the props of the component because it is a ClojureScript data structure. Let's have a look at them using Fulcro Inspect!

1. Open now the **Fulcro Inspect** tab and its **Element** sub-tab.
2. Click the _Pick Element_ in the top left corner and then click "Item 1" in the webapp
3. You should now see the details of the TodoItem, including
  * its "_ident_", meaning "identifier", namely `[:item/id 1]`
  * its _props_, including `:item/complete` and `:item/label`
    (click the ▶ to expand them)
  * its _query_ - notice how the props mostly mirror the query
4. Mark "Item 1" as complete by clicking to the left of its label and change its text by double-clicking on it and typing something then clicking outside of the list. How have the props changed? +
_Beware_: You might need to _Pick Element_ again to see the changes
  * Notice that for most purposes, having a prop with the value `false` and not having the prop at all are equivalent
5. _Pick_ another list item element and compare its values with the original item
6. Select the whole `TodoList` and look at its ident, props, and query

LESSON: We have learned to use _Fulcro Inspect - Element_ to explore a component and we have learned that it has props, ident, and a query. We saw that the props mirror what is specified in the query.

### 3. Exploring the query

The query of a component declares its data needs and Fulcro uses it to build the props for the component. We have seen it using Fulcro Inspect - Element, now we will explore it using the REPL.

1. Open `src/fulcro_todomvc/ui.cljs`, scroll to the bottom and inside the `(comment ...)` find _Exercise 3.1_ and evaluate the `get-query` call, read the result
+
NOTE: The evaluation result is displayed both inline and inside the `output.calva-repl` file (_Go - Go to File..._ to reopen it)

2. Now let's look at what the props look like - at the same place, under _Exercise 3.2_, eval the `(-> ... (comp/props) ..))` form. 
   _Note_: We used `tap>` so the data will not show up in the REPL but in a tap client. So open the http://localhost:9630/inspect-latest[Shadow-cljs Inspect Latest] in a new tab of the same browser and eval the form again. The value should appear in the Shadow Inspect; at the very bottom, **click _Pretty-Print_** to make it readable.
Compare the props and the query (and notice it is the same thing we saw in the Element tab)
3. Repeat for `TodoList` (remember you can find its ident using the Element tab)
+
We see that `TodoList` queries for these props (some omitted): `[:list/id :list/items :list/title :list/filter]`.
+
But it also elaborates what it wants for each of the `:list/items` elements, namely `[:item/id :item/label :item/complete ...]`. How does it do that? By combining the two using a map, to produce a so called "join":
+
```clojure
#{:list/items [:item/id :item/label :item/complete :ui/editing :ui/edit-text]}
```
+
and includes this in its query instead of just `:list/items`. Let's visualize how the query composes all the way to the Root:
+
.Query composition
image::images/query-composition.svg["Query composition",250]
+
Now https://github.com/holyjak/fulcro-intro-wshop/blob/4992e994cb51bef46d6aaca5f7515da9c9536fb0/src/fulcro_todomvc/ui.cljs#L123[look at the code] to see how the child's query is included - it is not simply pasted in the parent, it is included via `(comp/get-query TodoItem)`. This is important because it brings with it some important metadata. Let's have a look at it:

4. In `ui.cljs`, under _Exercise 3.4_, execute the form `(binding ...)` and explore te output in Shadow Inspect - pay attention to the metadata maps `^{...}` preceding some query vectors.

**EQL Primer**: An EQL query includes 1) _properties_ such as `:list/label`, 2) _joins_ of the form `{<property or ident> <query>}`, 3) or _idents_ such as `[:item/id 1]` to ask for the data of the entity with that ident (and we can again use a join to precise what data)

LESSON: Components declare their data needs using `:query`, listing the properties they want. They _join_ in the query of each child using `get-query` to include the child's needs and thus to specify what properties of a nested data entity to include. The query also includes metadata that Fulcro needs for its processing.

### 4. Root query

Despite a common misconception, Fulcro does not supply props to every and each component individually. It only supplies props to the root component - and it uses only the root query, which composes the queries of its children and so on, as we have seen. So let's have a look at the query and how it is turned into a props tree.

1. Open `src/fulcro_todomvc/ui.cljs`, scroll to the bottom and inside the `(comment ...)` evaluate the `get-query Root` form
2. It is little long and hard to read so open the http://localhost:9630/inspect-latest[Shadow-cljs Inspect Latest] in a new tab of the same browser and then evaluate the `(tap> ...)` call. The value should appear in the Shadow Inspect; at the very bottom, **click _Pretty-Print_**
3. Now let's see how Fulcro fulfills that query from the client DB, using `fdn/db->tree` - execute the form marked _Exercise 4.3_ and observe the result in Shadow's Inspect Latest. First use _Pretty-Print_ on it then switch to _Browse_ - you can click on any line to "drill in" and you can use the `<` and `<<` to go (all the way) back

LESSON: The Root query is turned to a props tree using the client DB. Shadow Inspect is a fine tool for looking at complex data.

### 5. Exploring the client DB

This is the Root query: 

.Root query:
```clojure
[{:root/todo
  [:list/id
   :ui/new-item-text
   {:list/items
    [:item/id :item/label :item/complete :ui/editing :ui/edit-text]}
   :list/title 
   :list/filter]}]
```

We will use it to navigate the client DB to see how Fulcro builds the props tree:

1. Switch to _Fulcro Inspect_ - _DB Explorer_
2. At the very bottom, under _Top-Level Keys_ (which are all the keys in the DB that are not "entity tables", such as `:item/id`), there is `:root/todos` - which is also the beginning of the Root's query. Click on its value to "drill down". You will see the list 1 data map, displayed as table, with properties on the left and values on the right. Compare it to the query then drill down to one of the items. Notice that an item is not included in a list but referred to from the list using its ident.
3. Open _Fulcro Inspect_ - _DB_ and click on the little triangle ▶ to expand the `:list/id` and `:item/id` "tables". Now we can see the same data as before, but all at once.
4. Let's see now how the raw data of the client DB looks like. Go to `ui.cljs` and execute the _Exercise 5.4_ form, then switch to _Shadow - Inspect Latest_ to look at it and _Pretty-Print_ it. +
Notice that you are looking at the very _same data_ that you can see in Fulcro Inspect - DB.

LESSON: We saw how data is stored in the client DB mostly in a normalized form (`<entity name>/id -> <id value> -> <map of props, with idents as values to link to other entities>`) and how idents are used to link entities together. We have experienced how Fulcro fulfills a query by "walking" the client DB. We have seen that the client DB is nothing else than a map (of maps of maps, mostly).

----

**TO BE CONTINUED**

1. load!-ing data from the server, transactions
2. mutations
3. DB - demonstrate going back in history b/c it is cool

## Next steps

If you want to learn more Fulcro, study the https://fulcro-community.github.io/guides/tutorial-minimalist-fulcro/[Minimalist Fulcro Tutorial] and do the accompanying exercises.